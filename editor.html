<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RPGマップエディタ</title>
    <style>
      body {
        user-select: none; /* テキスト選択を防ぐ */
        overflow: hidden;
      }
      .button-img {
        width: 32px; /* 幅を指定 */
        height: 32px; /* 高さを指定 */
        object-fit: cover; /* 画像のアスペクト比を維持 */
      }
      .button {
        background-color: rgb(207, 246, 235); /* ボタンの背景色 */
        border: 2px solid #add8e6; /* 薄い青色の枠線 */
        font-size: 16px; /* テキストサイズ */
      }

      .button:hover {
        background-color: rgb(243, 255, 251); /* ボタンの背景色 */
      }

      #dragElement {
        position: absolute;
        user-select: none; /* テキスト選択を防ぐ */
      }
      #mapCanvas {
        border: 1px solid black;
      }
      #toolContainer {
        position: fixed;
        top: 0px; /* 画面の上から10px */
        right: 0px; /* 画面の右から10px */
        padding: 10px;
        height: 100%;
        box-sizing: border-box; /* パディングを含むサイズ計算 */
        border: 1px solid #8e8e8e;
        background-color: rgb(224, 224, 224);
        z-index: 10;
      }
      #paletteContainer {
        margin: 0 0 10px 0;
        width: 320px;
        height: 65%;
        border: 1px solid #ccc;
        background-color: rgb(245, 222, 222);
        font-size: 18px;
        overflow: scroll;
      }
      #palette {
        display: flex;
        flex-wrap: wrap;
      }
      #palette img {
        overflow-y: auto; /* 縦方向のスクロールを許可 */
        width: 32px;
        height: 32px;
        margin: 2px;
        cursor: pointer;
        object-fit: contain;
      }
      .selected {
        border: 2px solid red;
      }
      #layerlistContainer {
        height: 120px; /* Fixed height */
        overflow-y: auto; /* Enable vertical scrolling if needed */
        background-color: lightblue;
        margin: 10px 0 0 0;
        padding: 5px;
        border: 1px solid;
        font-size: 16px;
      }
      #layersList {
        margin-top: 10px;
      }
      #layersList div {
        cursor: pointer;
        padding: 5px;
        border: 1px solid #ccc;
        margin-bottom: 5px;
      }
      #layersList div.active {
        background-color: #d7eeef;
      }
    </style>
  </head>
  <body>
    <div>
      <label for="mapWidth">マップの幅:</label>
      <input type="number" id="mapWidth" value="20" min="1" />
      <label for="mapHeight">マップの高さ:</label>
      <input type="number" id="mapHeight" value="15" min="1" />
      <button id="createMapButton">マップを作成</button>
    </div>

    <div>
      <input type="file" id="folderInput" webkitdirectory directory multiple />
    </div>
    <div id="toolContainer">
      <div id="paletteContainer">
        <div id="palette"></div>
      </div>
      <button id="saveButton" class="button">
        <img src="icon/down.png" alt="down" class="button-img" />
      </button>
      <button id="loadButton" class="button">
        <img src="icon/up.png" alt="up" class="button-img" />
      </button>
      <input type="file" id="loadInput" style="display: none" />
      <button id="eraserButton" class="button">
        <img src="icon/eraser.png" alt="eraser" class="button-img" />
      </button>
      <button id="pencilButton" class="button">
        <img src="icon/pen.png" alt="pen" class="button-img" />
      </button>
      <button id="addLayerButton" class="button">
        <img src="icon/add.png" alt="add" class="button-img" />
      </button>
      <br />
      <div id="layerlistContainer">
        <div id="layersList"></div>
      </div>
    </div>
    <br />
    <button id="toggleButton" class="button">
      <img src="icon/pen.png" alt="add" class="button-img" />
    </button>

    <div id="dragElement">
      <canvas id="mapCanvas" width="640" height="480"></canvas>
    </div>
    <br />

    <script>
      const palette = document.getElementById("palette");
      const mapCanvas = document.getElementById("mapCanvas");
      const ctx = mapCanvas.getContext("2d");
      const folderInput = document.getElementById("folderInput");
      const saveButton = document.getElementById("saveButton");
      const loadButton = document.getElementById("loadButton");
      const loadInput = document.getElementById("loadInput");
      const eraserButton = document.getElementById("eraserButton");
      const pencilButton = document.getElementById("pencilButton");
      const addLayerButton = document.getElementById("addLayerButton");
      const layersList = document.getElementById("layersList");
      const mapWidthInput = document.getElementById("mapWidth");
      const mapHeightInput = document.getElementById("mapHeight");
      const createMapButton = document.getElementById("createMapButton");
      const toggleButton = document.getElementById("toggleButton");

      let isDraggingEnabled = false;
      let selectedTile = null;
      let isEraserMode = false;
      let isDrawing = false;

      let tileSize = 32;
      let layers = [];
      let activeLayerIndex = 0;
      let tilesetData = [];
      let tileImages = {};

      function onMouseMove(event) {
        if (!isDraggingEnabled) return;
        moveAt(event.pageX, event.pageY);
      }

      function moveAt(pageX, pageY) {
        dragElement.style.left = pageX - shiftX + "px";
        dragElement.style.top = pageY - shiftY + "px";
      }

      let shiftX, shiftY;

      dragElement.onmousedown = function (event) {
        if (!isDraggingEnabled) return;
        event.preventDefault();

        shiftX = event.clientX - dragElement.getBoundingClientRect().left;
        shiftY = event.clientY - dragElement.getBoundingClientRect().top;

        moveAt(event.pageX, event.pageY);

        document.addEventListener("mousemove", onMouseMove);

        dragElement.onmouseup = function () {
          document.removeEventListener("mousemove", onMouseMove);
          dragElement.onmouseup = null;
        };
      };

      toggleButton.onclick = function () {
        isDraggingEnabled = !isDraggingEnabled;
        if (isDraggingEnabled) {
          toggleButton.innerHTML =
            '<img src="icon/toggle.png" alt="toggle" class="button-img">';
          dragElement.style.cursor = "move";
          mapCanvas.style.pointerEvents = "none";
        } else {
          toggleButton.innerHTML =
            '<img src="icon/pen.png" alt="toggle-a" class="button-img">';
          dragElement.style.cursor = "default";
          mapCanvas.style.pointerEvents = "auto";
        }
      };

      function resizeImage(img, width, height) {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, width, height);
        return canvas.toDataURL("image/png");
      }

      function updateLayersList() {
        layersList.innerHTML = "";
        layers.forEach((layer, index) => {
          const div = document.createElement("div");
          div.textContent = layer.name;
          div.onclick = () => setActiveLayer(index);
          if (index === activeLayerIndex) {
            div.classList.add("active");
          }
          layersList.appendChild(div);
        });
      }

      function setActiveLayer(index) {
        activeLayerIndex = index;
        updateLayersList();
        drawLayers();
      }

      function addLayer() {
        const newLayer = {
          name: `レイヤー ${layers.length + 1}`,
          map: Array(mapHeight)
            .fill()
            .map(() => Array(mapWidth).fill(null)),
        };
        layers.push(newLayer);
        setActiveLayer(layers.length - 1);
      }

      addLayerButton.addEventListener("click", addLayer);

      function drawLayers() {
        ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);

        layers.forEach((layer) => {
          layer.map.forEach((row, y) => {
            row.forEach((tileIndex, x) => {
              if (tileIndex !== null && tileImages[tileIndex]) {
                ctx.drawImage(
                  tileImages[tileIndex],
                  x * tileSize,
                  y * tileSize,
                  tileSize,
                  tileSize
                );
              }
            });
          });
        });
      }

      createMapButton.addEventListener("click", () => {
        const width = parseInt(mapWidthInput.value);
        const height = parseInt(mapHeightInput.value);

        if (width > 0 && height > 0) {
          mapWidth = width;
          mapHeight = height;

          layers = [
            {
              name: "レイヤー 1",
              map: Array(mapHeight)
                .fill()
                .map(() => Array(mapWidth).fill(null)),
            },
          ];

          activeLayerIndex = 0;
          updateLayersList();

          mapCanvas.width = mapWidth * tileSize;
          mapCanvas.height = mapHeight * tileSize;

          drawLayers();
        } else {
          alert("1以上の整数で指定してください。");
        }
      });

      function encodeImageAsBase64(imageUrl, callback) {
        const img = new Image();
        img.crossOrigin = "Anonymous"; // Allow cross-origin image loading
        img.onload = function () {
          const canvas = document.createElement("canvas");
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          callback(canvas.toDataURL("image/png"));
        };
        img.src = imageUrl;
      }

      folderInput.addEventListener("change", (event) => {
        const files = event.target.files;
        tilesetData = [];
        palette.innerHTML = "";

        let loadedImagesCount = 0;
        const totalImagesCount = files.length;

        for (let file of files) {
          if (file.type.startsWith("image/")) {
            const reader = new FileReader();
            reader.onload = function (e) {
              encodeImageAsBase64(e.target.result, (base64Image) => {
                const paletteImg = document.createElement("img");
                paletteImg.src = base64Image;

                palette.appendChild(paletteImg);
                paletteImg.onclick = () => selectTile(paletteImg);

                tilesetData.push({
                  name: file.name,
                  src: base64Image,
                });

                const tileImgIndex = tilesetData.length - 1;
                const tileImg = new Image();
                tileImg.src = base64Image;

                tileImg.onload = () => {
                  tileImages[tileImgIndex] = tileImg;
                  loadedImagesCount++;
                  if (loadedImagesCount === totalImagesCount) {
                    drawLayers();
                  }
                };
              });
            };
            reader.readAsDataURL(file);
          }
        }
      });
      function selectTile(img) {
        selectedTile = img.src;
        [...palette.children].forEach((child) => {
          child.classList.toggle("selected", child === img);
        });

        // Switch to pencil mode when a tile is selected
        if (isEraserMode) {
          isEraserMode = false;
          eraserButton.classList.remove("selected");
          pencilButton.classList.add("selected");
        }
      }

      function draw(e) {
        if (!isDrawing || isDraggingEnabled) return;

        const rect = mapCanvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / tileSize);
        const y = Math.floor((e.clientY - rect.top) / tileSize);

        if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return;

        if (isEraserMode) {
          layers[activeLayerIndex].map[y][x] = null;
        } else if (selectedTile) {
          const tileIndex = tilesetData.findIndex(
            (tile) => tile.src === selectedTile
          );
          if (tileIndex !== -1) {
            layers[activeLayerIndex].map[y][x] = tileIndex;
          }
        }

        drawLayers();
      }

      mapCanvas.addEventListener("mousedown", (e) => {
        if (selectedTile !== null) {
          isDrawing = true;
          draw(e);
        }
      });

      mapCanvas.addEventListener("mousemove", draw);

      mapCanvas.addEventListener("mouseup", () => {
        isDrawing = false;
      });

      mapCanvas.addEventListener("mouseout", () => {
        isDrawing = false;
      });

      eraserButton.addEventListener("click", () => {
        isEraserMode = true;
        eraserButton.classList.add("selected");
        pencilButton.classList.remove("selected");
      });

      pencilButton.addEventListener("click", () => {
        isEraserMode = false;
        pencilButton.classList.add("selected");
        eraserButton.classList.remove("selected");
      });

      saveButton.addEventListener("click", () => {
        const json = JSON.stringify({
          layers: layers,
          tilesetData: tilesetData,
        });
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "map.json";
        a.click();
        URL.revokeObjectURL(url);
      });

      loadButton.addEventListener("click", () => {
        loadInput.click();
      });

      loadInput.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            const json = JSON.parse(e.target.result);
            layers = json.layers;
            tilesetData = json.tilesetData;

            tileImages = {};
            palette.innerHTML = ""; // Clear the existing palette
            tilesetData.forEach((tile, index) => {
              const paletteImg = document.createElement("img");
              paletteImg.src = tile.src;
              palette.appendChild(paletteImg);
              paletteImg.onclick = () => selectTile(paletteImg);

              const tileImg = new Image();
              tileImg.src = tile.src;
              tileImg.onload = () => {
                tileImages[index] = tileImg;

                // Automatically select the first tile once it is loaded
                if (index === 0) {
                  selectTile(paletteImg);
                }
              };
            });

            setActiveLayer(0);

            // Ensure eraser mode is reset after loading
            isEraserMode = false;
            eraserButton.classList.remove("selected");
            pencilButton.classList.add("selected");

            // Update the canvas after the images have been loaded
            // To ensure all images are loaded before updating the canvas
            const imagesLoaded =
              Object.keys(tileImages).length === tilesetData.length;
            if (imagesLoaded) {
              drawLayers();
            } else {
              // Set up a check to redraw layers once all images are loaded
              const interval = setInterval(() => {
                if (Object.keys(tileImages).length === tilesetData.length) {
                  clearInterval(interval);
                  drawLayers();
                }
              }, 100);
            }
          };
          reader.readAsText(file);
        }
      });
    </script>
  </body>
</html>
